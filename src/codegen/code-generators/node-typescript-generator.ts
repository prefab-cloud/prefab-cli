import {stripIndent} from 'common-tags'
import camelCase from 'lodash.camelcase'

import {ZodToTypescriptMapper, type ZodToTypescriptMapperTarget} from '../language-mappers/zod-to-typescript-mapper.js'
import {ZodToTypescriptReturnValueMapper} from '../language-mappers/zod-to-typescript-return-value-mapper.js'
import {BaseTypescriptGenerator} from './base-typescript-generator.js'

export class NodeTypeScriptGenerator extends BaseTypescriptGenerator {
  get filename(): string {
    return 'prefab-server.ts'
  }

  generate(): string {
    return stripIndent`
    /* eslint-disable */
    // AUTOGENERATED by prefab-cli's 'gen' command
    import {Prefab, Contexts} from '@prefab-cloud/prefab-cloud-node'
    ${this.additionalDependencies().join('\n') || '// No additional dependencies required'}

    type ContextObj = Record<string, Record<string, unknown>>

    declare namespace PrefabTypeGeneration {
      export type NodeServerConfigurationRaw = {
        ${this.generateSchemaTypes('raw').join('\n        ') || '// No types generated'}
      }

      export type NodeServerConfigurationAccessor = {
        ${this.generateSchemaTypes().join('\n        ') || '// No types generated'}
      }
    }

    export class PrefabTypesafeNode {
      constructor(private prefab: Prefab) { }

      get<K extends keyof PrefabTypeGeneration.NodeServerConfigurationRaw>(key: K, contexts?: Contexts | ContextObj): PrefabTypeGeneration.NodeServerConfigurationRaw[K] {
        return this.prefab.get(key, contexts) as PrefabTypeGeneration.NodeServerConfigurationRaw[K]
      }

      ${this.generateAccessorMethods().join('\n\n      ') || '// No methods generated'}
    }
    `
  }

  private additionalDependencies(): string[] {
    const dependencies: string[] = []
    const hasFunctions = this.configurations().some((c) => c.hasFunction)

    if (hasFunctions) {
      dependencies.push(this.MUSTACHE_IMPORT)
    }

    return dependencies
  }

  private generateAccessorMethods(): string[] {
    const uniqueMethods: Record<string, string> = {}
    const schemaTypes = this.configurations().map((config) => {
      let methodName = camelCase(config.key)

      // If the method name starts with a digit, prefix it with an underscore to ensure method name is valid
      if (/^\d/.test(methodName)) {
        methodName = `_${methodName}`
      }

      console.log(config.key, methodName)

      if (uniqueMethods[methodName]) {
        throw new Error(
          `Method '${methodName}' is already registered. Prefab key ${config.key} conflicts with '${uniqueMethods[methodName]}'!`,
        )
      }

      uniqueMethods[methodName] = config.key

      if (config.hasFunction) {
        const returnValue = new ZodToTypescriptReturnValueMapper().resolveType(config.schema)

        return stripIndent`
          ${methodName}(contexts?: Contexts | ContextObj): PrefabTypeGeneration.NodeServerConfigurationAccessor['${config.key}'] {
                  const raw = this.get('${config.key}', contexts)
                  return ${returnValue}
                }
          `
      }

      return stripIndent`
        ${methodName}(contexts?: Contexts | ContextObj): PrefabTypeGeneration.NodeServerConfigurationAccessor['${config.key}'] {
                return this.get('${config.key}', contexts)
              }
          `
    })

    return schemaTypes
  }

  private generateSchemaTypes(target: ZodToTypescriptMapperTarget = 'accessor'): string[] {
    const schemaTypes = this.configurations().flatMap((config) => {
      const mapper = new ZodToTypescriptMapper({fieldName: config.key, target})

      return mapper.renderField(config.schema)
    })

    return schemaTypes
  }
}
