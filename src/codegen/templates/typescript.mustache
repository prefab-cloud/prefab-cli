// AUTOGENERATED CODE - DO NOT EDIT
// AUTOGENERATED with prefab-cli's gen command
import { z } from "zod";
import { Prefab, Contexts } from "@prefab-cloud/prefab-cloud-node";
import Mustache from 'mustache';
type ContextObj = Record<string, Record<string, unknown>>;

type ZodRawShape = Record<string, z.ZodTypeAny>;

/**
 * Creates a schema where all fields are optional but throw when accessing an undefined value.
 * This ensures we can parse a partial object and access provided values. It will throw when
 * missing values are accessed.
 */
function optionalRequiredAccess<T extends ZodRawShape>(shape: T) {
  // Make all fields optional
  const optionalShape: ZodRawShape = {};

  for (const key in shape) {
    optionalShape[key] = shape[key];
  }

  // Create the schema with optional fields and apply a proxy to throw when accessing a missing value
  return z.object(optionalShape).transform(obj => {
    return new Proxy(obj, {
      get(target: Record<string | symbol, any>, prop: string | symbol) {
        // Handle special symbols for JS runtime
        if (typeof prop === 'symbol') {
          return Reflect.get(target, prop);
        }

        // For regular string properties
        if (prop in target && target[prop] !== undefined) {
          return target[prop];
        }

        throw new Error(`Property ${String(prop)} is required but was not provided`);
      }
    });
  });
}

// Generated parameter schemas for methods that use Mustache templates
{{#accessorMethods}}
{{#paramsSchema}}
const {{paramsSchemaName}} = {{{paramsSchema}}};
{{/paramsSchema}}
{{/accessorMethods}}

export const prefabSchema = z.object({
  {{{schemaLines}}}
});

export type PrefabConfig = z.infer<typeof prefabSchema>;

export class PrefabTypesafe {
  constructor(private prefab: Prefab) { }

  get<K extends keyof PrefabConfig>(key: K, contexts?: Contexts | ContextObj): PrefabConfig[K] {
    const value = this.prefab.get(key, contexts);
    return prefabSchema.shape[key].parse(value) as PrefabConfig[K];
  }

{{{accessorMethods}}}
}