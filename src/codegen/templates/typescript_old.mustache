import { z } from "zod";
import { Prefab } from "@prefab-cloud/prefab-cloud-node";
import Mustache from 'mustache';

// Export all schemas as named constants
{{#schemaConfigs}}
export const {{schemaName}} = {{{zodSchema}}};
{{/schemaConfigs}}

// Generated schemas for validation
{{#schemaLines}}
const {{schemaName}} = {{{zodType}}};
{{/schemaLines}}

// Generated parameter schemas for methods that use Mustache templates
{{#accessorMethods}}
{{#paramsSchema}}
const {{paramsSchemaName}} = {{{paramsSchema}}};
{{/paramsSchema}}
{{/accessorMethods}}

export const prefabSchema = z.object({
{{#schemaLines}}
  "{{key}}": {{schemaName}},
{{/schemaLines}}
});

export type PrefabConfig = z.infer<typeof prefabSchema>;

export class PrefabTypesafe {
  constructor(private prefab: Prefab) { }

  get<K extends keyof PrefabConfig>(key: K): PrefabConfig[K] {
    const value = this.prefab.get(key);
    return prefabSchema.shape[key].parse(value) as PrefabConfig[K];
  }

  {{#accessorMethods}}
  {{methodName}}({{#params}}{{params}}{{/params}}): {{{returnType}}} {
    {{#jsonTemplate}}
    const json = this.get('{{key}}');
    
    // Transform template strings into functions
    return {{{implementation}}};
    {{/jsonTemplate}}
    
    {{#stringTemplate}}
    const value = this.get('{{key}}');
    
    // Handle string template
    if (typeof value === 'string') {
      return Mustache.render(value, params || {});
    }
    
    throw new Error(`Expected string for {{key}}, got ${typeof value}`);
    {{/stringTemplate}}
    
    {{#simpleValue}}
    // Simple value, no template processing needed
    return this.get('{{key}}');
    {{/simpleValue}}
  }
  {{/accessorMethods}}
}

// Add a duration validator to zod
declare module "zod" {
  interface ZodString {
    duration(): ZodString;
  }
}

if (z.string().duration === undefined) {
  z.string().prototype.duration = function () {
    return this;
  };
}